---
name: opposite-case
description: Build the strongest possible case against your current position or belief to test its robustness, avoid confirmation bias, and ensure balanced thinking
---

# Opposite Case

Deliberately build the strongest argument against your current position to test its strength.

## Instructions

When building the opposite case:

1. **State your current position**: What do you believe or propose?
   - Be specific and clear
   - Note your confidence level
   - Acknowledge your investment in this position

2. **Switch perspectives completely**:
   - Imagine you MUST argue against this
   - What would a smart skeptic say?
   - Channel someone who disagrees

3. **Build the strongest counter-argument**:
   - Find the best evidence against
   - Highlight weaknesses in your position
   - Point out what you're ignoring
   - Use your position's logic against itself
   - Don't strawman - make it genuinely strong

4. **Address multiple angles**:
   - **Factual**: What facts contradict this?
   - **Logical**: Where's the reasoning flawed?
   - **Practical**: Why won't this work in practice?
   - **Historical**: When has this failed before?
   - **Alternative**: What's a better approach?

5. **Present compelling alternatives**:
   - Don't just tear down, build up alternatives
   - Show why opposite approach is superior
   - Make the alternative attractive

6. **Find the partial truth**:
   - Where is the opposition actually right?
   - What valid concerns do they raise?
   - What can you learn from this perspective?

7. **Return to your position**:
   - How does it hold up?
   - What needs modification?
   - Where were you overconfident?

## Examples

### Opposite case for a technical decision:
"**My position**: We should rewrite this legacy system

**Building the opposite case**:
The legacy system works. It's handled our business for 10 years without major incidents. Yes, it's ugly, but ugly working code is better than beautiful broken code.

A rewrite means:
- 6-12 months where no new features ship
- Introducing new bugs into stable functionality
- Losing years of edge-case handling
- Disrupting team velocity
- No guarantee the new system is actually better

The 'technical debt' isn't preventing us from delivering value - we shipped 20 features last quarter. The real problem isn't the code; it's that we don't understand it. Documenting and refactoring would be 10x cheaper than rewriting.

Most rewrites fail or take 3x longer than estimated. Remember when Company X tried this? Two years later they rolled back. The legacy system has actual battle-tested reliability you can't replicate quickly.

**What I learned**: The rewrite desire might be more about developer comfort than business value. Should consider incremental refactoring instead."

### Opposite case for a hypothesis:
"**My belief**: Users abandon because our checkout is confusing

**The opposite case**:
The checkout is fine. Millions of e-commerce sites use similar flows successfully. Users understand how to buy things online - they do it everywhere else.

The real issue is they never intended to buy. They're using the cart to save items or check total prices. Our 'abandonment' metric is measuring normal browsing behavior, not failed purchases.

Look at the data differently:
- 'Abandoned' carts often return later
- Abandonment rate is industry standard
- Successful purchasers use the same 'confusing' checkout

We're pattern-matching to a problem that doesn't exist. The checkout works for people ready to buy. The others weren't going to buy regardless of the checkout design.

Fixing the checkout won't change abandonment because checkout isn't the problem - product-market fit is.

**Valid points raised**: Should segment genuine purchase attempts from browsing behavior before concluding checkout is broken."

## When to use this skill

- Before major decisions
- Testing your assumptions
- Preparing for criticism
- Strengthening proposals
- Overcoming confirmation bias
- Understanding opposition
- Debate preparation
- Investment decisions